# -*- coding: utf-8 -*-
"""low_matrices.ipynb

Automatically generated by Colab.

Original file is located at
https://colab.research.google.com/drive/1LFy0xoRLop25NGWKuVXblUOBZ-NTvcsa
"""

from IPython.display import display, Math
import numpy as np
import pandas as pd
import sympy as sp
from sympy import symbols, sympify, Matrix, Eq, solve, expand, Abs, pprint, factor
from itertools import permutations, product, chain
import scipy

"""# rsk stuff"""

def bracketing(vec1, vec2):
    """
    Given two vectors (row or column), stack them and generate a flat bracket list:
    - ']' for counts from vec1 (first)
    - '[' for counts from vec2 (second)
    """
    brackets = []

    if vec1.ndim == 1:
        vec1 = vec1.reshape(1, -1)
    if vec2.ndim == 1:
        vec2 = vec2.reshape(1, -1)

    if vec1.shape[0] == 1 and vec2.shape[0] == 1:
        m_slice = np.vstack([vec1, vec2])
        for j in range(m_slice.shape[1]):
            brackets.extend([']'] * int(m_slice[0, j]))
            brackets.extend(['['] * int(m_slice[1, j]))
    elif vec1.shape[1] == 1 and vec2.shape[1] == 1:
        m_slice = np.hstack([vec1, vec2])
        for i in range(m_slice.shape[0]):
            brackets.extend([']'] * int(m_slice[i, 0]))
            brackets.extend(['['] * int(m_slice[i, 1]))
    return brackets

def clean_brackets(row1, row2):
    brackets = bracketing(row1, row2)
    brackets = np.array(brackets)

    while True:
        if len(brackets) == 0 or np.count_nonzero(brackets == '[') == 0:
            return True, brackets
        original = brackets.copy()

        left_mask = np.where(brackets == '[')[0]
        if len(left_mask) > 0:
            first_open_idx = left_mask[0]
            if first_open_idx > 0 and np.all(brackets[:first_open_idx] == ']'):
                brackets = brackets[first_open_idx:]

        right_mask = np.where(brackets == ']')[0]
        if len(right_mask) > 0:
            last_close_idx = right_mask[-1]
            if last_close_idx < len(brackets) - 1 and np.all(brackets[last_close_idx + 1:] == '['):
                brackets = brackets[:last_close_idx + 1]

        i = 0
        while i < len(brackets) - 1:
            if brackets[i] == '[' and brackets[i + 1] == ']':
                brackets = np.delete(brackets, [i, i + 1])
                break
            else:
                i += 1

        if np.array_equal(brackets, original):
            break

    return False, brackets

def rsk_insert(tableau, x):
    tableau = tableau.copy()
    rows, cols = tableau.shape
    bumped = x
    for r in range(rows):
        row = tableau[r]
        mask = (row > 0)
        eligible = row[mask]
        idx = np.where(eligible > bumped)[0]
        if idx.size == 0:
            insert_pos = np.sum(mask)
            if insert_pos < cols:
                tableau[r, insert_pos] = bumped
                return tableau, (r, insert_pos)
            else:
                continue
        else:
            i = idx[0]
            bumped, tableau[r, i] = tableau[r, i], bumped
    empty_row = np.zeros(cols, dtype=int)
    empty_row[0] = bumped
    tableau = np.vstack([tableau, empty_row])
    return tableau, (tableau.shape[0] - 1, 0)

def viennot_rsk(biword):
    n = len(biword)
    P = np.zeros((n, n), dtype=int)
    Q = np.zeros((n, n), dtype=int)
    for a, b in biword:
        P, (r, c) = rsk_insert(P, a)
        Q[r, c] = b
    return P, Q

def print_tableau(tableau, name='T'):
    print(f"{name}:")
    for row in tableau:
        row_nonzero = row[row > 0]
        if row_nonzero.size > 0:
            print(row_nonzero)

def generateChunks(k: int):
    final = []
    base = np.eye(k)[::-1]
    bases = [base * i for i in range(0, k + 1)]

    fill_positions = [(i, j) for i in range(k) for j in range(k) if i + j < k - 1]
    combos = list(product(range(k + 1), repeat=len(fill_positions)))

    for b in bases:
        for c in combos:
            mat = np.zeros((k, k), dtype=int)
            for idx, (i, j) in enumerate(fill_positions):
                mat[i, j] = c[idx]
            mat = mat + b
            final.append(mat)
    return final

def all_kxk_matrices(k: int):
    vals = range(k + 1)
    for combo in product(vals, repeat=k * k):
        yield np.array(combo).reshape((k, k))

def create_giant(a, b, c, k):
    giant = np.zeros((2 * k, 2 * k))
    giant[:k, :k] = a
    giant[:k, k:] = b
    giant[k:, :k] = c
    return giant

def check_matrix(mat):
    vals = []
    for row in mat:
        nz = row[row != 0]
        if len(nz) == 0:
            continue
        if not np.all(nz == nz[0]):
            return False
        vals.append(nz[0])
    return np.all(np.diff(vals) > 0)



def gen_giants(A, B, C, k):
    count = 0
    max = 10000
    giants = {}
    for a in A:
        for b in B:
            for c in C:
                if np.any(a) and np.any(b) and np.any(c):
                    giant = create_giant(a, b, c, k)
                    giants[count] = [a, b, c, giant]
                    count += 1
                    if count == max:
                        break
            if count == max:
                break
        if count == max:
            break
    return giants

def biword(M: np.array) -> list:
    biword_P = []
    biword_Q = []
    for j in range(M.shape[1]):
        for i in range(M.shape[0]):
            cell_value = int(M[i, j])
            if cell_value != 0:
                biword_P.extend([i + 1] * cell_value)
                biword_Q.extend([j + 1] * cell_value)
    return list(zip(biword_P, biword_Q))

def border_check(arr, k):
    row_flag = True
    col_flag = True

    for i in chain(range(0, k - 1), range(k, 2 * k - 1)):
        row_flag, _ = clean_brackets(arr[i], arr[i + 1])
        
        if not row_flag:
            return False

    for j in chain(range(0, k - 1), range(k, 2 * k - 1)):
        col_flag, _ = clean_brackets(arr[:, j], arr[:, j + 1])
        
        if not col_flag:
            return False
    return row_flag

def original_check(arr, k):
    row_flag = True
    col_flag = True

    for i in range(k):
        row_flag, _ = clean_brackets(arr[i], arr[i + 1])
        if not row_flag:
            return False

    for j in range(k):
        col_flag, _ = clean_brackets(arr[:, j], arr[:, j + 1])
        if not col_flag:
            return False
    return row_flag

def new_examples(giants, k, limit=None):
    new_giants = {}
    count = 0
    for g in giants:
        if limit is not None and count >= limit:
            break
        target = giants[g][-1]
        t_biword = biword(target)
        P, Q = viennot_rsk(t_biword)
        if check_matrix(P) and check_matrix(Q):
            continue
        if border_check(target, k):
            new_giants[count] = [giants[g][0], giants[g][1], giants[g][2], target]
            count += 1
    return new_giants

def filter(giants, k, limit=None):
    new_giants = {}
    count = 0
    for g in giants:
        if limit is not None and count >= limit:
            break
        target = giants[g][-1]
        t_biword = biword(target)
        P, Q = viennot_rsk(t_biword)
        if check_matrix(P) and check_matrix(Q):
            continue
        if border_check(target, k):
            new_giants[count] = [giants[g][0], giants[g][1], giants[g][2], target]
            count += 1
    return new_giants

def masking(arr, k):
    arr[arr <= k] = 0
    return arr

def gen_giants_AB_var(A, B, k):
    count = 0
    max = 10000
    c = np.zeros((k, k))
    giants = {}
    for a in A:
        for b in B:
            if np.any(a) and np.any(b):
                giant = create_giant(a, b, c, k)
                giants[count] = [a, b, c, giant]
                count += 1
                if count == max:
                    break
        if count == max:
            break
    return giants

def gen_giants_AC_var(A, C, k):
    count = 0
    max = 10000
    giants = {}
    b = np.zeros((k, k))
    for a in A:
        for c in C:
            if np.any(a) and np.any(c):
                giant = create_giant(a, b, c, k)
                giants[count] = [a, b, c, giant]
                count += 1
                if count == max:
                    break
        if count == max:
            break
    return giants

def processing(target):
    t_biword = biword(target)
    P, Q = viennot_rsk(t_biword)
    return P, Q

def print_side_by_side(A, B, sep=' | '):
    for row_a, row_b in zip(A, B):
        row_a_str = ' '.join(str(int(x)) for x in row_a)
        row_b_str = ' '.join(str(int(x)) for x in row_b)
        print(f"{row_a_str}{sep}{row_b_str}")

def print_nonzero_rows(arr):
    for row in arr:
        if np.all(row == 0):
            continue  # skip all-zero rows
        print(row)

def search_masked_examples(ab_giants, ac_giants, k, limit=None):
    count = 0
    result = []
    if len(ab_giants.keys()) == len(ac_giants.keys()):
        for i in range(len(ab_giants.keys())):
            if limit is not None and count >= limit:
                break
            target_ab = ab_giants[i][-1]
            target_ac = ac_giants[i][-1]
            a = ab_giants[i][0]
            b = ab_giants[i][1]
            c = ac_giants[i][2]

            pq_ac = biword(target_ac)
            pq_ab = biword(target_ab)
            
            p_ac, _ = viennot_rsk(pq_ac)
            _, q_ab = viennot_rsk(pq_ab)

            og = create_giant(a, b, c, k)

            p_ac = masking(p_ac, k)
            q_ab = masking(q_ab, k)

            result.append((p_ac, q_ab, og, p_ac, q_ab))
    return result

def testing(ab_giants, ac_giants, k, limit=None):
    count = 0
    if len(ab_giants.keys()) == len(ac_giants.keys()):
        for i in range(len(ab_giants.keys())):
            if limit is not None and count >= limit:
                break
            target_ab = ab_giants[i][-1]
            target_ac = ac_giants[i][-1]
            a = ab_giants[i][0]
            b = ab_giants[i][1]
            c = ac_giants[i][2]

            pq_ac = biword(target_ac)
            pq_ab = biword(target_ab)
            
            p_ac, q_ac = viennot_rsk(pq_ac)
            p_ab, q_ab = viennot_rsk(pq_ab)

            og = create_giant(a, b, c, k)
            bi = biword(og)
            # og_p, og_q = viennot_rsk(bi)

            p_ac = masking(p_ac, k)
            q_ab = masking(q_ab, k)

            if p_ac.shape == q_ab.shape:
                if (p_ac == q_ab).all():
                    print("ALERT")
                    print(og)
                    print(target_ab)
                    print(target_ac)
                    print_side_by_side(p_ac, q_ab)
                    break


def tuple_list(tuple_list):
    p = [t[0] for t in tuple_list]
    q = [t[-1] for t in tuple_list]
    return p, q

# if __name__ == "__main__":
#     A = np.array([
#         [0, 0, 0, 1],
#         [0, 1, 1, 0],
#         [0, 1, 0, 0],
#         [1, 0, 0, 0]
#     ])

#     B = np.array([
#         [0, 0, 0, 1],
#         [1, 0, 1, 0],
#         [0, 1, 0, 0],
#         [1, 0, 0, 0]
#     ])

#     # Top-left 2x2 block: A_a
#     A_a = A[:2, :2]
#     B_a = B[:2, :2]

#     # Top-right 2x2 block: A_b
#     A_b = A[:2, 2:]
#     B_b = B[:2, 2:]

#     # Bottom-left 2x2 block: A_c
#     A_c = A[2:, :2]
#     B_c = B[2:, :2]

#     print("A")
#     A_ab = create_giant(A_a, A_b, np.zeros((2,2)), 2)
#     A_ac = create_giant(A_a, np.zeros((2,2)), A_c, 2)

#     bi_A_ab = biword(A_ab)
#     bi_A_ac = biword(A_ac)

#     p_ac_1, _ = viennot_rsk(bi_A_ac)
#     _, q_ab_1 = viennot_rsk(bi_A_ab)

#     print_side_by_side(p_ac_1, q_ab_1)

#     print("B")
#     B_ab = create_giant(B_a, B_b, np.zeros((2,2)), 2)
#     B_ac = create_giant(B_a, np.zeros((2,2)), B_c, 2)

#     bi_B_ab = biword(B_ab)
#     bi_B_ac = biword(B_ac)

#     p_ac_2, _ = viennot_rsk(bi_B_ac)
#     _, q_ab_2 = viennot_rsk(bi_B_ab)

#     print_side_by_side(p_ac_2, q_ab_2)

def gen_ABC0_giants(A, B, C, k, max_count=10000):
    """
    Returns dictionary: {index: (A, B, C, giant, zero_block)}
    where giant = [ A | B ]
                  [ C | 0 ]
    """
    giants = {}
    count = 0
    zero_block = np.zeros((k, k), dtype=int)
    for a in A:
        for b in B:
            for c in C:
                if not (np.any(a) and np.any(b) and np.any(c)):
                    continue
                giant = create_giant(a, b, c, k)
                giants[count] = (a, b, c, giant, zero_block)
                count += 1
                if count >= max_count:
                    return giants
    return giants


def filter_ABC0_by_bracketing(giants_dict, k):
    """
    Filters giants that pass original_check and returns lists of (A, B), (A, C)
    """
    ab_list = []
    ac_list = []
    for _, (a, b, c, giant, _) in giants_dict.items():
        if original_check(giant, k):
            ab_list.append((a, b))
            ac_list.append((a, c))
    return ab_list, ac_list

def filter_new_ABC0_by_bracketing(giants_dict, k):
    """
    Filters giants that pass original_check and returns lists of (A, B), (A, C)
    """
    ab_list = []
    ac_list = []
    for _, (a, b, c, giant, _) in giants_dict.items():
        if border_check(giant, k):
            ab_list.append((a, b))
            ac_list.append((a, c))
    return ab_list, ac_list

if __name__ == "__main__":
    C = np.array([
    [0, 0, 1, 0],
    [0, 2, 0, 0],
    [1, 0, 0, 0],
    [1, 0, 0, 0]
    ])

    D = np.array([
        [0, 0, 2, 0],
        [0, 1, 0, 0],
        [2, 1, 0, 0],
        [1, 0, 0, 0]
    ])

    print(border_check(C, 2))