# -*- coding: utf-8 -*-
"""low_matrices.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LFy0xoRLop25NGWKuVXblUOBZ-NTvcsa
"""

from IPython.display import display, Math
import numpy as np
import pandas as pd
import sympy as sp
from sympy import symbols, sympify, Matrix, Eq, solve, expand, Abs, pprint, factor
from itertools import permutations
import scipy

"""# rsk stuff"""

def rsk_insert(tableau, x):
    tableau = tableau.copy()
    rows, cols = tableau.shape
    bumped = x
    for r in range(rows):
        row = tableau[r]
        mask = (row > 0)
        eligible = row[mask]
        idx = np.where(eligible > bumped)[0]
        if idx.size == 0:
            insert_pos = np.sum(mask)
            if insert_pos < cols:
                tableau[r, insert_pos] = bumped
                return tableau, (r, insert_pos)
            else:
                continue
        else:
            i = idx[0]
            bumped, tableau[r, i] = tableau[r, i], bumped
    empty_row = np.zeros(cols, dtype=int)
    empty_row[0] = bumped
    tableau = np.vstack([tableau, empty_row])
    return tableau, (tableau.shape[0] - 1, 0)

def viennot_rsk(biword):
    n = len(biword)
    P = np.zeros((n, n), dtype=int)
    Q = np.zeros((n, n), dtype=int)
    for a, b in biword:
        P, (r, c) = rsk_insert(P, a)
        Q[r, c] = b
    return P, Q

def print_tableau(tableau, name='T'):
    '''
    for debugging
    @params tableau is a numpy array
    @params name is a string
    '''
    print(f"{name}:")
    for row in tableau:
        row_nonzero = row[row > 0]
        if row_nonzero.size > 0:
            print(row_nonzero)

from itertools import product
import numpy as np

def generateChunks(k: int):
    final = []
    base = np.eye(k)[::-1]  # antidiagonal identity
    bases = [base * i for i in range(0, k + 1)]

    # Count positions above antidiagonal
    fill_positions = [(i, j) for i in range(k) for j in range(k) if i + j < k - 1]
    combos = list(product(range(k + 1), repeat=len(fill_positions)))

    for b in bases:
        for c in combos:
            mat = np.zeros((k, k), dtype=int)
            for idx, (i, j) in enumerate(fill_positions):
                mat[i, j] = c[idx]
            mat = mat + b
            final.append(mat)
    return final

def all_kxk_matrices(k: int):
    vals = range(k + 1)
    for combo in product(vals, repeat=k * k):
        yield np.array(combo).reshape((k, k))

def create_giant(a, b, c, k):
  giant = np.zeros((2*k, 2*k))
  giant[:k, :k] = a
  giant[:k, k:] = b
  giant[k:, :k] = c
  return giant

import numpy as np

def check_matrix(mat):
    vals = []
    for row in mat:
        nz = row[row != 0]
        if len(nz) == 0:
            continue  # skip empty rows
        if not np.all(nz == nz[0]):
            return False
        vals.append(nz[0])
    return np.all(np.diff(vals) > 0)

B = generateChunks(3)
C = generateChunks(3)
A = all_kxk_matrices(3)

count = 0
max = 10000
giants = {}
for a in A:
  for b in B:
    for c in C:
      giant = create_giant(a, b, c, 3)
      giants[count] = [a, b, c, giant]
      count += 1
      if count == max:
        break
    if count == max:
      break
  if count == max:
    break

import numpy as np

def biword(M: np.array) -> list:
  '''given a matrix M return the corresponding biword
  Args:
    - M: generic np.array
  '''
  # biword goes from left to right col-wise and top to bottom row-wise
  biword_P = []
  biword_Q = []
  for j in range(M.shape[1]):
    for i in range(M.shape[0]):
        # Ensure the element is treated as an integer for the multiplication
        cell_value = int(M[i, j])
        if cell_value != 0:
            biword_P.extend([i + 1] * cell_value)
            biword_Q.extend([j + 1] * cell_value)
  return list(zip(biword_P, biword_Q))

# arr = np.array([
#     [1, 0, 0, 1, 0, 0],
#     [0, 1, 0, 0, 0, 0],
#     [0, 0, 0, 0, 0, 0],
#     [1, 0, 0, 0, 0, 0],
#     [0, 0, 0, 0, 0, 0],
#     [0, 0, 0, 0, 0, 0]
# ])
# temp = [arr]
for g in giants:
    target = giants[g][-1]
    t_biword = biword(target)
    P, Q = viennot_rsk(t_biword)
    if check_matrix(P) and check_matrix(Q):
        print(target)
        for pr, qr in zip(P.astype(int).tolist(), Q.astype(int).tolist()):
              print(f"P: {pr} | Q: {qr}")
        print()  # blank line between entries

arr = np.array([
    [0, 0, 0, 0, 3, 0],
    [0, 0, 0, 3, 0, 0],
    [0, 0, 3, 0, 0, 0],
    [3, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0]
])
b = biword(arr)
p,q = viennot_rsk(b)
print(p)
print(q)