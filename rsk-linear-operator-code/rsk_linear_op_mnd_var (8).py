# -*- coding: utf-8 -*-
"""RSK_Linear_OP_mnd_var.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iCptKJXE3CCQyZcAq7JKMbwfuWj_OVrZ
"""

from IPython.display import display, Math
import numpy as np
import pandas as pd
import sympy as sp
from sympy import symbols, sympify, Matrix, Eq, solve, expand, Abs, pprint, factor
from itertools import permutations
import scipy
import math

"""# Attempt at Coding Algorithm A

Change pi and sig below to test RSK_(pi,sig) col/sum pairs


---



## Functions Reference:
### Functions for RSK_{pi,sig}
```
  - contingency_tables(row_sums, col_sums):
      - @param row_sums:
      - @param col_sums:
      - Calculates the contingency tables for given row and column sum vectors based on the n-Queens problem (backtracking)

  - generate_monomials(tables, sig, pi):
      - @param tables
      - @param sig
      - @param pi

  - rsk_insert(tableau, x):
  - viennot_rsk(biword):
  - print_tableau(tableau, name='T'):
  - determinant():
  - generate_final_matrix():
  - foo():
  - display_matrix():
```


---


### Functions for RSK_{m,n,d}
```
  - contingency_vectors():
  - generate_matrices():
  -
```


"""

def contingency_tables(row_sums, col_sums):
    '''
    This function generates the contingency tables
    for a given set of row and column sums
    using a backtracking/recursive approach.
    '''
    m, n = len(row_sums), len(col_sums)
    result = []

    def backtrack(row, table, col_sums_left):
        if row == m:
            if all(c == 0 for c in col_sums_left):
                result.append(np.array(table))
            return

        def valid_next_rows(rsum, cols_left, partial=[]):
            if len(partial) == n:
                if sum(partial) == rsum:
                    yield list(partial)
                return
            i = len(partial)
            max_entry = min(rsum - sum(partial), cols_left[i])
            for x in range(max_entry + 1):
                yield from valid_next_rows(rsum, cols_left, partial + [x])

        for row_vals in valid_next_rows(row_sums[row], col_sums_left):
            new_cols = [c - x for c, x in zip(col_sums_left, row_vals)]
            if all(c >= 0 for c in new_cols):
                backtrack(row + 1, table + [row_vals], new_cols)

    backtrack(0, [], col_sums)
    return result

def generate_monomials(tables, pi, sig):
    '''
    This function simply fills out the above dictionaries and lists
    @params tables is a list of contingency tables generated by the above function
    '''
    m, n = len(sig), len(pi)

    # Create symbols z_ij for monomial basis
    z = Matrix(m, n, lambda i, j: symbols(f"z{i+1}{j+1}"))

    monomials = []  # monomials[i] returns the monomial generated for the ith contingency table
    idx_dict = {} # idx_dict[i] returns the sequence of bump chains to be inserted for the ith contingency table
    exp_dict = {} # exp_dict[i] returns a a dictionary of monomials paired with their respective exponent for the ith contingency table

    idx = 0 # dummy counter
    for table in tables:
        mon = 1
        temp_idx = []
        temp_exp_idx = []
        table_dict = {}
        for j in range(m):
            for i in range(n):
                exp = table[i][j]
                if exp > 0:
                    pair = (i + 1, j + 1)
                    temp_idx.extend([pair] * exp)
                    mon *= z[i, j]**exp
                    if z[i, j] not in table_dict:
                        table_dict[z[i, j]] = exp
                    else:
                        table_dict[z[i, j]] += exp
        exp_dict[idx] = table_dict
        idx_dict[idx] = temp_idx

        idx += 1
        monomials.append(mon)

    return monomials, idx_dict, exp_dict, z

def rsk_insert(tableau, x):
    tableau = tableau.copy()
    rows, cols = tableau.shape
    bumped = x
    for r in range(rows):
        row = tableau[r]
        mask = (row > 0)
        eligible = row[mask]
        idx = np.where(eligible > bumped)[0]
        if idx.size == 0:
            insert_pos = np.sum(mask)
            if insert_pos < cols:
                tableau[r, insert_pos] = bumped
                return tableau, (r, insert_pos)
            else:
                continue
        else:
            i = idx[0]
            bumped, tableau[r, i] = tableau[r, i], bumped
    empty_row = np.zeros(cols, dtype=int)
    empty_row[0] = bumped
    tableau = np.vstack([tableau, empty_row])
    return tableau, (tableau.shape[0] - 1, 0)

def viennot_rsk(biword):
    n = len(biword)
    P = np.zeros((n, n), dtype=int)
    Q = np.zeros((n, n), dtype=int)
    for a, b in biword:
        P, (r, c) = rsk_insert(P, a)
        Q[r, c] = b
    return P, Q

def print_tableau(tableau, name='T'):
    '''
    for debugging
    @params tableau is a numpy array
    @params name is a string
    '''
    print(f"{name}:")
    for row in tableau:
        row_nonzero = row[row > 0]
        if row_nonzero.size > 0:
            print(row_nonzero)

def determinant(P, Q, z_matrix):
  '''
  This function generates the determinant
  for the given RSK correspondence tableaus
  P and Q. @params idx refers to the ith
  contingency table.
  '''
  det_collection = []

  for col_idx in range(P.shape[1]):
      n_val = np.count_nonzero(P[:, col_idx]) # Renamed local n to n_val to avoid confusion
      p_col = P[:, col_idx]
      q_col = Q[:, col_idx]
      det = Matrix.zeros(n_val,n_val)
      for i, p_val in enumerate(p_col):
        for j, q_val in enumerate(q_col):
          if p_val != 0 and q_val != 0:
            key = z_matrix[p_val - 1, q_val - 1]
            det[i, j] = key
      det_collection.append(det)

  expr = 1
  for det in det_collection:
    minor_det = det.det()
    expr *= minor_det
  expr = expand(expr)
  return expr

def generate_final_matrix(monomial_mapping, determinant_list):
    '''
    This block of code uses the initial
    dictionary to fill out the final matrix
    '''

    final_matrix = np.zeros((len(monomial_mapping), len(monomial_mapping)))
    final_matrix

    final_size = len(monomial_mapping)
    for col_idx in range(final_size):
        curr_list = determinant_list[col_idx]
        final_slice = final_matrix[:, col_idx]

        for term in curr_list.as_ordered_terms():
          coeff, monomial = term.as_coeff_Mul()

          if monomial in monomial_mapping:
              row_idx = monomial_mapping[monomial]
              final_slice[row_idx] = coeff

          elif -monomial in monomial_mapping:
              row_idx = monomial_mapping[-monomial]
              final_slice[row_idx] = -coeff

        final_matrix[:, col_idx] = final_slice
    return final_matrix

def foo(matrix):
        '''
        function that may be a bit faster than np.linalg.eig()
        @params matrix is a numpy array
        '''
        eigenvalues, eigenvectors = np.linalg.eig(matrix)
        for eigenvalue in np.unique(eigenvalues):
            algebraic_multiplicity = np.sum(eigenvalues == eigenvalue)

            eigenvectors_for_eigenvalue = eigenvectors[:, eigenvalues == eigenvalue]
            geometric_multiplicity = np.linalg.matrix_rank(eigenvectors_for_eigenvalue)

            if algebraic_multiplicity != geometric_multiplicity:
                return False
        return True

def display(final_matrix):
    print(f"Sigma: {sig}")
    print(f"Pi: {pi}")
    print(f"Trace: {np.linalg.trace(final_matrix)}")
    print(f"is Diagonalizable: {foo(final_matrix)}" )
    print(f"Determinant: {np.linalg.det(final_matrix)}")
    char_poly_coeffs = np.poly(final_matrix)
    x = symbols('x')
    num_char_poly_coeffs = len(char_poly_coeffs)
    char_poly = [char_poly_coeffs[n] * x**(num_char_poly_coeffs - n - 1) for n in range(num_char_poly_coeffs)]
    pretty_eq = sp.latex(factor(sum(char_poly)))
    pprint(f"Characteristic Polynomial:")
    print(display(Math(pretty_eq)))

"""<!-- end of fxn code--!>"""

3# row/col margins
# sig[i] = sum of row i
# pi[i] = sum of col i

print("If pi and sig are not the same length, please pad the smaller array with zeroes")

# pi = [int(x) for x in input("Enter pi: ").split(",")]
# sig = [int(x) for x in input("Enter sig: ").split(",")]
pi = [1, 1, 1]
sig = [2, 1, 0]
# pi = [3, 5, 0]
# sig = [3, 2, 3]
m, n = len(sig), len(pi)

# Create symbols z_ij for monomial basis
z = Matrix(m, n, lambda i, j: symbols(f"z{i+1}{j+1}"))

# table sanity check
tables = contingency_tables(sig, pi)
tables = tables[::-1]
for t in tables:
    print(t, end="\n\n")

# gives the correct hashing order for the ordered monomial basis
monomials, idx_dict, exp_dict, z = generate_monomials(tables, pi, sig)
monomial_mapping = {mon: i for i, mon in enumerate(monomials)}; monomial_mapping

numpy_tableaus = [viennot_rsk(index) for index in idx_dict.values()] # converting our bump chains(?) into Tableaus P and Q

determinant_list = [determinant(P, Q, z) for i, (P, Q) in enumerate(numpy_tableaus)] # determinants generated from P,Q

final_matrix = generate_final_matrix(monomial_mapping, determinant_list)

from IPython.display import display, Math

final_matrix = generate_final_matrix(monomial_mapping, determinant_list)

print(f"Sigma: {sig}")
print(f"Pi: {pi}")
print(final_matrix)
print(f"Trace: {np.linalg.trace(final_matrix)}")
print(f"is Diagonalizable: {foo(final_matrix)}" )
print(f"Determinant: {np.linalg.det(final_matrix)}")
char_poly_coeffs = np.poly(final_matrix)
x = symbols('x')
num_char_poly_coeffs = len(char_poly_coeffs)
char_poly = [char_poly_coeffs[n] * x**(num_char_poly_coeffs - n - 1) for n in range(num_char_poly_coeffs)]
pretty_eq = sp.latex(factor(sum(char_poly)))
pprint(f"Characteristic Polynomial:")
print(display(Math(pretty_eq)))

def RSK_pi_sig(r_pair: list, show=False) -> tuple:
  '''

  '''
  sig, pi = r_pair
  m, n = len(sig), len(pi)

  tables = contingency_tables(sig, pi)
  monomials, idx_dict, exp_dict, z_local = generate_monomials(tables, pi, sig)

  numpy_tableaus = [viennot_rsk(index) for index in idx_dict.values()]
  determinant_list = [determinant(P, Q, z_local) for P, Q in numpy_tableaus]
  monomial_mapping = {mon: i for i, mon in enumerate(monomials)}; monomial_mapping

  final_matrix = generate_final_matrix(monomial_mapping, determinant_list)

  if show:
    display(final_matrix)

  return final_matrix

"""# V1 code for RSK_{m,n,d}:
- @param m,n: len of pi/sig weight vectors
- @param d: degree
"""

def contingency_vectors(n, d):
    '''
    This function generates the possible contingency vectors
    @params n: len of vector
    @params d: degree
    '''
    vectors = []
    def recusion(vector, degrees_left):
        if len(vector) == n:
            vectors.append(vector)
            return
        for i in range(degrees_left + 1)[::-1]:
            new_vector = vector + [i]

            if len(new_vector) == n:  # pruning
                vectors.append(new_vector)
                return

            recusion(new_vector, degrees_left - int(i))

    recusion([], d)
    return vectors

def generate_matrices(m, n, d):
    '''
    This function generates the RSK_{m,n,d} matrices
    @params m,n: len of pi/sig weight vectors can assume m = n
    @params d: degree
    '''
    contingency_vectors_list = contingency_vectors(m, d)
    contingency_vector_map = {i : tuple(vector) for i, vector in enumerate(contingency_vectors_list)}
    matrices = []
    final_dim = 0
    for pi in contingency_vector_map.values():
        for sig in contingency_vector_map.values():
            # tables = contingency_tables(sig, pi)
            # monomials, idx_dict, exp_dict, z_local = generate_monomials(tables, pi, sig)
            # numpy_tableaus = [viennot_rsk(index) for index in idx_dict.values()]
            # determinant_list = [determinant(P, Q, z_local) for P, Q in numpy_tableaus]
            # monomial_mapping = {mon: i for i, mon in enumerate(monomials)}; monomial_mapping
            final_matrix = RSK_pi_sig((sig, pi), show=False)
            final_dim += final_matrix.shape[0]
            matrices.append(final_matrix)
    return matrices

from scipy.linalg import block_diag
m = 3
d = 2
matrices = generate_matrices(m,m,d)
final_rsk_matrix = block_diag(*matrices)

from scipy.linalg import block_diag
from IPython.display import display, Math
'''
Edit m and d below to obtain the desired RSK_{m,m,d} matrix
'''
m = 3
d = 3
matrices = generate_matrices(m,m,d)
final_rsk_matrix = block_diag(*matrices)

def foo(matrix):
    eigenvalues, eigenvectors = np.linalg.eig(matrix)
    for eigenvalue in np.unique(eigenvalues):
        algebraic_multiplicity = np.sum(eigenvalues == eigenvalue)

        eigenvectors_for_eigenvalue = eigenvectors[:, eigenvalues == eigenvalue]
        geometric_multiplicity = np.linalg.matrix_rank(eigenvectors_for_eigenvalue)

        if algebraic_multiplicity != geometric_multiplicity:
            return False
    return True
print(f"m: {m}")
print(f"n: {n}")
print(f"d: {d}")
print(f"Trace: {np.linalg.trace(final_rsk_matrix)}")
print(f"Determinant: {np.linalg.det(final_rsk_matrix)}")

"""# 3.22 Code for R_{m, n, d} Block Decomp

Core idea:
- find subset of (pi, sig) in d
- find trace by adding all Tr(pi, sig)
- find determinant by multiplying all determinant
"""

from collections import defaultdict

def partitions_by_largest_vec(n: int) -> list:
    """
    Returns a list where index i contains all partitions of n whose maximum value is i
    """
    partition_dict = defaultdict(list)

    def helper(remaining, current):
        if remaining == 0:
            max_val = max(current)
            partition_dict[max_val].append(current[:])
            return
        for i in range(1, remaining + 1):
            helper(remaining - i, current + [i])

    helper(n, [])

    max_index = max(partition_dict.keys(), default=0)
    partition_vec = [[] for _ in range(max_index + 1)]
    for k, v in partition_dict.items():
        partition_vec[k] = v

    return partition_vec

def reduced_pair(partition_vec: list, d: int) -> list:
  '''
  Input:
  - partition_vec: list of valid partitions for a given d
  - d: degree
  Output:
  - red_pairs: list of valid reduced pairs for a given d

  **KEY: parition_vec[i][j] is the jth partition whose MAXIMUM value is i
  '''
  red_pairs = []

  for i in range(len(partition_vec) - 1, -1, -1):
      for pi in partition_vec[i]:
          upper_bound = min(i, d - i)
          if upper_bound < 0:
              continue
          for j in range(upper_bound, -1, -1):
              for pj in partition_vec[j]:
                  red_pairs.append((pi, pj))

  return red_pairs

def gp(g: list[list]) -> int:
  ''' growth pot. is just the number of zeroes in g (?) '''
  return np.count_nonzero(g == 0)

def A(r_pair:list, d: int) -> int:
  '''
  '''
  sig, pi = r_pair

  dp = sum(sig)
  g = growth_p_matrix(r_pair, d)
  growth_pot = gp(g)
  if np.count_nonzero(pi) >= 3:
    if growth_pot:
      n = (d - dp) + (growth_pot - 1)
      k = growth_pot - 1
      return math.comb(n, k)
    else:
      return dp == d
  else: #idk if this is the r conditional
    return 4*(d - dp) + (dp == d)

def multiplicity(sig, pi, m, n, d):
    g = gp(growth_p_matrix((sig, pi), d))
    return (
        math.comb(d, g)
        * math.comb(m, np.count_nonzero(sig))
        * math.comb(n, np.count_nonzero(pi))
    )

def pad_pair(r_pair):
  ''' helper fxn for padding '''
  a, b = r_pair
  n = max(len(a), len(b))
  return [
      a + [0] * (n - len(a)),
      b + [0] * (n - len(b))
  ]

def all_reduced_pairs_up_to_d(d):
    seen = set()
    pairs = []
    for d0 in range(1, d + 1):
        pv = partitions_by_largest_vec(d0)
        for sig, pi in reduced_pair(pv, d0):
            pair = tuple(map(tuple, pad_pair((sig, pi))))
            if pair not in seen:
                seen.add(pair)
                pairs.append(pair)
    return pairs

def growth_p_matrix(r_pair: list, d: int)-> list[list]:
  '''
  Input:
  - r_pair: a reduced pair from reduced_pair()
  - d: dimension
  Output:
  - g: a growth matrix for the given reduced pair
  '''
  sig, pi = r_pair
  m, n = len(sig), len(pi)
  g = np.zeros((m, n), dtype = int)
  for i in range(m):
    for j in range(n):
      g[i][j] = sig[i] + pi[j] - d
  return g

def N0(m: int, n: int, d: int) -> int:
  ''''''
  return math.comb(d + n - 1, d)*m + math.comb(d + m - 1, d)*n - m*n

def all_reduced_pairs_up_to_d(d):
    seen = set()
    pairs = []
    for d0 in range(1, d + 1):
        pv = partitions_by_largest_vec(d0)
        for sig, pi in reduced_pair(pv, d0):
            pair = tuple(map(tuple, pad_pair((sig, pi))))
            if pair not in seen:
                seen.add(pair)
                pairs.append(pair)
    return pairs

def block_decomp(m, n, d):
  trace_total = N0(m, n, d)
  det_total = 1

  for sig, pi in all_reduced_pairs_up_to_d(d):
    g = gp(growth_p_matrix((sig, pi), d))
    R = RSK_pi_sig((list(sig), list(pi)))
    tr = np.trace(R)
    det = np.linalg.det(R)

    N = multiplicity(list(sig), list(pi), m, n, d)

    trace_total += N * tr
    det_total *= det ** N

  return trace_total, det_total

trace_total, det_total = block_decomp(3, 3, 3)
print(f"Trace: {trace_total}")
print(f"Determinant: {det_total}")

def testing(d: int):
  partition_vec = partitions_by_largest_vec(d)
  red_pairs = reduced_pair(partition_vec, d)
  for pair in red_pairs:
    g = growth_p_matrix(pair, d)
    print(f"Reduced Pair: {pair}")
    print(g)

testing(3)

# check this later(?)

check_table = []
trace_table = []
for i in range(2, 3):
  temp_row_trace = []
  temp_row_det = []
  for d in range(2, 3):
    matrices = generate_matrices(i+1,i+1,d+1)
    final_rsk_matrix = block_diag(*matrices)
    print(final_rsk_matrix)
    trace = np.linalg.trace(final_rsk_matrix)
    det = np.linalg.det(final_rsk_matrix)
    temp_row_trace.append(trace)
    temp_row_det.append(det)
  check_table.append(temp_row_trace)
  trace_table.append(temp_row_det)
print(np.array(check_table))
print(np.array(trace_table))

"""m: 3
n: 5
d: 9
Trace: 660.0
Determinant: 0.9999999999999918

m = 3:
*   d = 8
  *   1m
  *   1
  *   270
*   d = 9
  *   5m
  *   1
  *   660

*   d = 10
  *

*   List item
"""