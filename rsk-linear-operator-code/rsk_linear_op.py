# -*- coding: utf-8 -*-
"""RSK_Linear_OP.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iCptKJXE3CCQyZcAq7JKMbwfuWj_OVrZ
"""

import numpy as np
import pandas as pd
from sympy import symbols, sympify, Matrix, pprint, Eq, solve, expand, Abs
from itertools import permutations
import scipy

# Attempt at coding Algorithm A in
# lists sig, pi
sig = [1, 1, 1]
pi = [1, 1, 1]
m, n = len(sig), len(pi)

# Create symbols z_ij
z = Matrix(m, n, lambda i, j: symbols(f"z{i+1}{j+1}"))
pprint(z)

# generating the monomial basis
def contingency_tables(row_sums, col_sums):
    m, n = len(row_sums), len(col_sums)
    result = []

    def backtrack(row, table, col_sums_left):
        if row == m:
            if all(c == 0 for c in col_sums_left):
                result.append(np.array(table))
            return

        def valid_next_rows(rsum, cols_left, partial=[]):
            if len(partial) == n:
                if sum(partial) == rsum:
                    yield list(partial)
                return
            i = len(partial)
            max_entry = min(rsum - sum(partial), cols_left[i])
            for x in range(max_entry + 1):
                yield from valid_next_rows(rsum, cols_left, partial + [x])

        for row_vals in valid_next_rows(row_sums[row], col_sums_left):
            new_cols = [c - x for c, x in zip(col_sums_left, row_vals)]
            if all(c >= 0 for c in new_cols):
                backtrack(row + 1, table + [row_vals], new_cols)

    backtrack(0, [], col_sums)
    return result

tables = contingency_tables(sig, pi)
print(f"Found {len(tables)} tables.")
# table sanity check
tables = tables[::-1]
for t in tables:
    print(t, end="\n\n")

monomials = []
idx_dict = {}
exp_dict = {}
idx = 0
for table in tables:
    mon = 1
    temp_idx = []
    temp_exp_idx = []
    for j in range(m):
        for i in range(n):
            exp = table[i][j]
            if exp > 0:
                temp_idx.append((i + 1, j + 1))
                temp_exp_idx.append(exp)
                mon *= z[i, j]**exp
    idx_dict[idx] = temp_idx
    exp_dict[idx] = temp_exp_idx
    idx += 1
    monomials.append(mon)

# print(idx_dict)
# print(monomials)
print(exp_dict)
# rmb that monomials ordered by col

final_result = np.zeros((len(monomials), len(monomials)))
# note to self enumerate is equiv to for i in ____ for iterating
monomial_mapping = {mon: i for i, mon in enumerate(monomials)}; monomial_mapping
# sympy enforces ordering by row idx!

def rsk_insert(sequence):
    P, Q = [], []

    for step, (x, label) in enumerate(sequence):
        i = 0
        to_insert = x

        while i < len(P):
            row = P[i]
            for j, y in enumerate(row):
                if to_insert < y:
                    row[j], to_insert = to_insert, y
                    break
            else:
                row.append(to_insert)
                break
            i += 1

        if i == len(P):
            P.append([to_insert])
        if i == len(Q):
            Q.append([label])
        else:
            Q[i].append(label)

    return P, Q

def to_square(arr):
    max_dim = max(len(arr), max(len(row) for row in arr))
    square = np.zeros((max_dim, max_dim), dtype=int)
    for i, row in enumerate(arr):
        for j, val in enumerate(row):
            square[i, j] = val
    return square

tableaus = [rsk_insert(index) for index in idx_dict.values()]; tableaus
numpy_tableaus = [(to_square(a), to_square(b)) for a, b in tableaus]
determinant_idx = {}
idx = 0

# for tableau in numpy_tableaus:
determinant_idx = {}
idx = 0
for tableau in numpy_tableaus:
  P, Q = tableau
  temp = []

  for col_idx in range(P.shape[1]):
      p_col = P[:, col_idx]
      q_col = Q[:, col_idx]

      p_vals = [p for p in p_col if p != 0]
      q_vals = [q for q in q_col if q != 0]

      for p in p_vals:
          for q in q_vals:
              if (p, q) not in temp:
                  temp.append((p, q))

  determinant_idx[idx] = temp
  idx += 1
# print(determinant_idx)
cleaned = {
    k: [(int(x), int(y)) for (x, y) in v]
    for k, v in determinant_idx.items()
}

print(cleaned)

# dummy holds list of monomials to be processed
dummy = {}
for idx in cleaned:
    det_idx = cleaned[idx]
    temp = []
    for pair in det_idx:
      x, y = pair
      temp.append(z[x-1, y-1])
    dummy[idx] = temp
print(dummy)

'''
  current jank formula:
  n <- dim of R
  len <- curr_len of list of monos
  if len == n:
      matrix.eye(mono_list).det()
  if len == (n - 1)^2 + 1
      mono_list * matrix.fill(mono_list[0:-2]).det()
  if len == n**2:
      matrix.det()
  can be optimized ! (later)
  exp_dict stores the exponents of each monomial in the list
'''
n = 3
final_list = []
for idx in dummy:
    monos = dummy[idx]
    exponents = exp_dict[idx]
    size = len(monos)
    # raised_monos = [m**e for m, e in zip(monos, exponents)]
    raised_monos = monos
    det = 1
    if size == n:
        det *= np.prod(raised_monos)
    if size == ((n - 1)**2 + 1):
        minor = Matrix(n - 1, n - 1, raised_monos[:((n-1)**2)])
        det *= minor.det() * raised_monos[((n-1)**2)]
        det = expand(det)
    if size == n**2:
        det = Matrix(n, n, raised_monos).det()
    final_list.append(det)
final_list

final_matrix = np.zeros((len(monomial_mapping), len(monomial_mapping)))
final_matrix
# monomial_mapping
# .args ==> iterable symbol
final_size = len(monomial_mapping)
for col_idx in range(final_size):
    curr_list = final_list[col_idx]
    final_slice = final_matrix[:, col_idx]
    for term in curr_list.as_ordered_terms():
      if term in monomial_mapping:
          row_idx = monomial_mapping[term]
          final_slice[row_idx] = curr_list.coeff(term, 1)
      if -term in monomial_mapping:
          row_idx = monomial_mapping[-term]
          final_slice[row_idx] = -curr_list.coeff(term, 1)
    final_matrix[:, col_idx] = final_slice
final_matrix

# todo: fix the exponent dictionary...